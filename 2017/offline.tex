\documentclass[12pt,a4paper]{jsarticle}

\usepackage{pxjahyper}
\renewcommand{\kanjifamilydefault}{\gtdefault} %For Japanese text

\usepackage[utf8]{inputenc} %Character code to utf-8
\usepackage{fancyhdr} % feader footer
\usepackage{lastpage}
\usepackage{graphicx}

\cfoot{\thepage}
\usepackage{listings} % sorcecode
\usepackage{inconsolata}

\renewcommand{\thelstnumber}{\arabic{lstnumber}:}
\lstset{language=C++,
  breaklines=true
  basicstyle=\sffamily,
  commentstyle=\textit,
  classoffset=1,
  keywordstyle=\bfseries,
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  tabsize=1
}

\title{君はゲームプログラマーになりたいか？ \\ 目指してるのは楽な道のりじゃないぜ}
\author{くらげ～}
\date{\today}

% From here text
\begin{document}

\maketitle
\section{君の名は？}
　1IのJOKENの中で生きている(執筆時)くらげ～です。プログラミングは8年。セキュリティは3年。人工知能は3ヵ月。やってます。まあ、中身を詳しく言うと、きりがないので割愛しますが、何年やってきたかはどうでもいいんだよ！やる気さえあればなんでもできる！(白目)僕のモットーは広く深く、やり方は基礎を完全に理解してから、一気に深く掘り下げていきます。それで勉強の効率化を図っています。僕の場合は基礎が定着していないと応用をしないので、最初の方は成長が遅いです。小学校の時がそうやった。

僕は別にゲームクリエイターになるつもりは現時点ではないが、スキルを身に着ける上で学習しながらOpenGLやVulkanでオブジェクト配置したりGLSL(OpenGL Shading Language)でminecraftの影mod(現時点では影処理しか書けない)を作ったりして楽しんでいる。ちなみに、影処理はShadow mappingって調べたらでてくるぜ！その他にもいろいろしているが...

まあ、そんなことはどうでもいい。ゲームプログラマーというものは知っているか？


\section{え？ゲームプログラマー？え、めっちゃかっこええやん}
　この世にはUnityやUNREAL ENGINE 4など様々なゲームエンジンがあって、それで物理現象などを考えずにクリックで重力を起こせたり,
さらにはオブジェクトを配置したりできる。これらのゲームエンジンだけでゲームを作成することができる。ただ、君はそこで満足するのか？ん？そこで満足していいと思ってるのか？

ゲームを作成するだけならUnityやUNREAL ENGINE 4の勉強をすればいい。でも、それはゲームクリエイターであってゲームプログラマーではない。ただ、これらのゲームエンジンを使ってはいけないとは誰も言っていない。ゲームを作成するうえで時間短縮、楽することは重要なことである。俺はゲームエンジンを使うことは賛成する人だ。だが、どのように描画されているのか知らないままゲームエンジンでゲームを作成していると、ゲーム作成の基礎が分かっていないことになるよな？な？だから、ちょっとでも足を突っ込んでみて、ゲームエンジンの中身までわからなくても、その初歩的なことでもわかればそれでも十分だよな！(この資料に全部書くとページが何枚あっても足りないのは秘密)


\section{本題に入る前に2次元/3次元グラフィックスプログラミングAPIの紹介をするぜ}
 まずは先ほど出てきたOpenGLからだ。こやつはクロノス・グループとかいうちょっとかっこいい名前をしている。そこが開発元だ。名前がかっこいいなみにやってることも侮れない。ちなみにこやつはCGAPI(コンピューターグラフィックスアプリケーションプログラミングインターフェイス)である。

まあ、わけわからない言葉がたくさん出てきたが、不安がる必要はない。最初から分かる天才なんてこの世に存在しねえ。OpenGLってのはJavaみたいに対応OSが幅広いのが特徴だ。ただ、C++みたいに簡単に学習できるような言語ではない少し複雑なAPIである。つい最近までは3Dゲームの作成などはこのAPIが主流であった(今も主流かも知れない)。C++と併用するのが多い。

次はDirectXというものだ。僕はこのAPIは少ししか触ったことがないので具体的にはいえないが。唯一いえることは、Windowsのみでしか動作しないことだ。Windowsだけで動作させる場合ならこの選択肢もありだろう。

その次にVulkanというものだ。こいつもクロノス・グループによって、開発されている。OpenGLの上位互換といってもいいAPIだ。ただOpenGLより難しいが、低レベルなAPIによって軽量な処理が可能になっている。今後主流になっていくであろうAPIであろう。

その他にもいろいろあるかもしれないが、俺は知らない。


\section{おい、さっさと本題行ってくれよ}
 まあまあ、待て待て。今回紹介するのはOpenGLとVulkanだが。同じ開発元だよな？じゃあ、何が違うんだ？
 
A:同じ開発元だからなんだって言いたいんだ。

me:いや...別に何もないです....

\section{OpenGLとVulkanの違いってなんだよ？}
 何が違うかといわれても、一見はほとんど違いはない。ただ簡単に言うと、Vulkanの方が多くのベンダーをサポートして効率的にGPUのリソースを使うことができる。何がVulkanの方が難しいか言うと、OpenGLではドライバによってメモリマネジメントや、スレッドマネジメント、コマンドバッファの生成や更新を自動でするが、Vulkanはそれをアプリケーション側でしないといけない。そこが難しい理由だ。ただ、勉強できないほど難しいものでもないので気になった人は勉強してみよう。
 そしてVulkanで描画したものはOpenGL内で使うことができるぞ！とても便利なのでVulkanも一緒に勉強しちゃおう！

\section{立方体を描画するぞ！}

\begin{lstlisting}[language=C++]
#define GLFW_INCLUDE_GLU
#include <iostream>
#include <GLFW/glfw3.h>
#define width 1280
#define height 960

static GLFWwindow*  window;

static const GLdouble CubeVertex[][3] = {
	{ 0.0, 0.0, 0.0 },
	{ 1.0, 0.0, 0.0 },
	{ 1.0, 1.0, 0.0 },
	{ 0.0, 1.0, 0.0 },
	{ 0.0, 0.0, 1.0 },
	{ 1.0, 0.0, 1.0 },
	{ 1.0, 1.0, 1.0 },
	{ 0.0, 1.0, 1.0 }
};

static const GLint CubeFace[][4] = {
	{ 0, 1, 2, 3 },
	{ 1, 5, 6, 2 },
	{ 5, 4, 7, 6 },
	{ 4, 0, 3, 7 },
	{ 4, 5, 1, 0 },
	{ 3, 2, 6, 7 }
};

static const GLdouble CubeNormal[][3] = {
	{ 0.0, 0.0,-1.0 },
	{ 1.0, 0.0, 0.0 },
	{ 0.0, 0.0, 1.0 },
	{ -1.0, 0.0, 0.0 },
	{ 0.0,-1.0, 0.0 },
	{ 0.0, 1.0, 0.0 }
};

static const GLfloat CubeMaterial[] = { 0.8, 0.35, 0.4, 1.0 };
static const GLfloat LightColor[] = { 0.2, 0.2, 0.8, 1.0 };
static const GLfloat Lightpos0[] = { 0.0, 3.0, 5.0, 1.0 };
static const GLfloat Lightpos1[] = { 5.0, 3.0, 0.0, 1.0 };


static void DrawCube()
{
	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, CubeMaterial);

	glBegin(GL_QUADS);
	for (size_t i = 0; i < 6; ++i)
	{
		glNormal3dv(CubeNormal[i]);
		for (size_t j = 0; j < 4; ++j)
		{
			glVertex3dv(CubeVertex[CubeFace[i][j]]);
		}
	}
	glEnd();
}

int main()
{

	if (glfwInit() == GL_FALSE)
	{
		std::cerr << "Error initilize GLFW" << std::endl;
		exit(EXIT_FAILURE);
		return 1;
	}

	window = glfwCreateWindow(width, height, "SampleCube", NULL, NULL);

	if (window == NULL)
	{
		std::cerr << "Error create GLFW window." << std::endl;
		glfwTerminate();
		exit(EXIT_FAILURE);
		return 1;
	}

	glfwMakeContextCurrent(window);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
	glLightfv(GL_LIGHT1, GL_SPECULAR, LightColor);
	glLightfv(GL_LIGHT1, GL_DIFFUSE, LightColor);
	// #82ffe6 is HTML color
	glClearColor(0.509f, 1.0f, 0.901f, 1.0f);

	while (glfwWindowShouldClose(window) == GL_FALSE)
	{

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glLoadIdentity();


		int now_width, now_height; //now_height isn't use
		glfwGetFramebufferSize(window, &now_width, &now_height);
		glViewport(0, 0, now_width, now_width * 0.75);
		gluPerspective(30.0, (double)width / (double)height, 1.0, 100.0);
		glTranslated(0.0, 0.0, -2.0);
		gluLookAt(3.0, 5.0, 4.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
		glLightfv(GL_LIGHT0, GL_POSITION, Lightpos0);
		glLightfv(GL_LIGHT1, GL_POSITION, Lightpos1);

		DrawCube();

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glfwTerminate();
	return EXIT_SUCCESS;
}
\end{lstlisting}

この上記のコードはOpenGLにおける立方体の描画プログラムだ。上から順に見ていこう！
まず\#includeだ。\#includeはC言語をベースとする言語におけるプリプロセッサディレクティブである。まあ簡単に言うと別のソースファイルを読み込んで、まとめて処理してくれる。ちなみに\#include\verb|<|bits/stdc++.h\verb|>|はg++環境でないと動作しないので注意が必要だ。\#include\verb|<|GLUT/glut.h\verb|>|はOpenGLに準拠したC言語ライブラリなので、これがないとOpenGLを使うことができない。

\end{document}
